// 200.岛屿数量[https://leetcode-cn.com/problems/number-of-islands/]
package main

import (
	"encoding/json"
	"fmt"
)

func main() {
	str := `[["1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","0","1","0","1","1"],["0","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","0"],["1","0","1","1","1","0","0","1","1","0","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","0","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","0","1","1","1","1","1","1","0","1","1","1","0","1","1","1","0","1","1","1"],["0","1","1","1","1","1","1","1","1","1","1","1","0","1","1","0","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","1","1"],["1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["0","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","0","1","1","1","1","1","1","1","0","1","1","1","1","1","1"],["1","0","1","1","1","1","1","0","1","1","1","0","1","1","1","1","0","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","0"],["1","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","0"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"]]`
	var arr [][]string
	json.Unmarshal([]byte(str), &arr)

	grid := make([][]byte, len(arr))
	for i := range arr {
		grid[i] = make([]byte, len(arr[i]))
		for j := range arr[i] {
			grid[i][j] = arr[i][j][0]
		}
	}
	count := numIslands(grid)
	fmt.Print(count)
}

func numIslands(grid [][]byte) int {
	row := len(grid)
	if row == 0 {
		return 0
	}

	col := len(grid[0])
	mark := make([][]int, row)
	for i := 0; i < row; i++ {
		mark[i] = make([]int, col)
	}

	island := make([]bool, 0)
	n := 0
	for i := 0; i < row; i++ {
		for j := 0; j < col; j++ {
			if grid[i][j] == '0' {
				continue
			}

			upConnected := i > 0 && grid[i-1][j] == '1'
			leftConnected := j > 0 && grid[i][j-1] == '1'
			upNum, leftNum := 0, 0

			if upConnected {
				upNum = mark[i-1][j]
				mark[i][j] = upNum
			}

			if leftConnected {
				leftNum = mark[i][j-1]
				mark[i][j] = leftNum

				if upConnected && upNum != leftNum {
					num := min(upNum, leftNum)
					for k := j; k >= 0 && mark[i][k] == leftNum; k-- {
						mark[i][k] = num
					}

					useless := max(upNum, leftNum)
					island[useless-1] = false
				}
			}

			if !upConnected && !leftConnected {
				island = append(island, true)
				mark[i][j] = n + 1
				n++
			}
		}
	}

	islandCount := 0
	for i := range island {
		if island[i] {
			islandCount++
		}
	}
	return islandCount
}

func min(x int, y int) int {
	if x < y {
		return x
	} else {
		return y
	}
}

func max(x int, y int) int {
	if x > y {
		return x
	} else {
		return y
	}
}
